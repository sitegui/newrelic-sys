/* automatically generated by rust-bindgen */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 29;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NEWRELIC_DATASTORE_FIREBIRD: &'static [u8; 9usize] = b"Firebird\0";
pub const NEWRELIC_DATASTORE_INFORMIX: &'static [u8; 9usize] = b"Informix\0";
pub const NEWRELIC_DATASTORE_MSSQL: &'static [u8; 6usize] = b"MSSQL\0";
pub const NEWRELIC_DATASTORE_MYSQL: &'static [u8; 6usize] = b"MySQL\0";
pub const NEWRELIC_DATASTORE_ORACLE: &'static [u8; 7usize] = b"Oracle\0";
pub const NEWRELIC_DATASTORE_POSTGRES: &'static [u8; 9usize] = b"Postgres\0";
pub const NEWRELIC_DATASTORE_SQLITE: &'static [u8; 7usize] = b"SQLite\0";
pub const NEWRELIC_DATASTORE_SYBASE: &'static [u8; 7usize] = b"Sybase\0";
pub const NEWRELIC_DATASTORE_MEMCACHE: &'static [u8; 10usize] = b"Memcached\0";
pub const NEWRELIC_DATASTORE_MONGODB: &'static [u8; 8usize] = b"MongoDB\0";
pub const NEWRELIC_DATASTORE_ODBC: &'static [u8; 5usize] = b"ODBC\0";
pub const NEWRELIC_DATASTORE_REDIS: &'static [u8; 6usize] = b"Redis\0";
pub const NEWRELIC_DATASTORE_OTHER: &'static [u8; 6usize] = b"Other\0";
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _nr_app_and_info_t {
    _unused: [u8; 0],
}
#[doc = " @brief A New Relic application.  Once an application configuration is"]
#[doc = " created with newrelic_create_app_config(), call newrelic_create_app()"]
#[doc = " to create an application to report data to the daemon; the daemon,"]
#[doc = " in turn, reports data to New Relic."]
#[doc = ""]
#[doc = " @see newrelic_create_app()."]
pub type newrelic_app_t = _nr_app_and_info_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _newrelic_txn_t {
    _unused: [u8; 0],
}
#[doc = " @brief A New Relic transaction. A transaction is started using"]
#[doc = " newrelic_start_web_transaction() or"]
#[doc = " newrelic_start_non_web_transaction(). A started, or active, transaction is"]
#[doc = " stopped using newrelic_end_transaction(). One may modify a transaction"]
#[doc = " by adding custom attributes or recording errors only after it has been"]
#[doc = " started."]
pub type newrelic_txn_t = _newrelic_txn_t;
#[doc = " @brief A time, measured in microseconds.  C SDK configuration and API"]
#[doc = " calls with time-related parameters expect this type.  For an example"]
#[doc = " configuration, see newrelic_transaction_tracer_config_t."]
pub type newrelic_time_us_t = u64;
#[doc = " The highest-priority loglevel; only errors are logged."]
pub const _newrelic_loglevel_t_NEWRELIC_LOG_ERROR: _newrelic_loglevel_t = 0;
#[doc = " The loglevel for warnings and errors."]
pub const _newrelic_loglevel_t_NEWRELIC_LOG_WARNING: _newrelic_loglevel_t = 1;
#[doc = " The loglevel for informational logs, warnings, and errors."]
pub const _newrelic_loglevel_t_NEWRELIC_LOG_INFO: _newrelic_loglevel_t = 2;
#[doc = " The highest-verbosity loglevel."]
pub const _newrelic_loglevel_t_NEWRELIC_LOG_DEBUG: _newrelic_loglevel_t = 3;
#[doc = " @brief Log levels.  An enumeration of the possible log levels for an SDK"]
#[doc = " configuration, or newrelic_app_config_t.  The highest priority loglevel"]
#[doc = " is NEWRELIC_LOG_ERROR.  The level NEWRELIC_LOG_DEBUG offers the greatest"]
#[doc = " verbosity."]
#[doc = ""]
#[doc = " @see newrelic_app_config_t"]
pub type _newrelic_loglevel_t = u32;
pub use self::_newrelic_loglevel_t as newrelic_loglevel_t;
#[doc = " When the record_sql field of the newrelic_transaction_tracer_config_t"]
#[doc = "  is set to NEWRELIC_SQL_OFF, no queries are reported to New Relic."]
pub const _newrelic_tt_recordsql_t_NEWRELIC_SQL_OFF: _newrelic_tt_recordsql_t = 0;
#[doc = " For the SQL-like datastores which are supported by the C SDK, when the"]
#[doc = "  record_sql field of the newrelic_transaction_tracer_config_t is set"]
#[doc = "  to NEWRELIC_SQL_RAW the query param of the"]
#[doc = "  newrelic_datastore_segment_config_t is reported as-is to New Relic."]
#[doc = ""]
#[doc = "  @warning This setting is not recommended."]
pub const _newrelic_tt_recordsql_t_NEWRELIC_SQL_RAW: _newrelic_tt_recordsql_t = 1;
#[doc = " For the SQL-like datastores which are supported by the C SDK, when the"]
#[doc = "  record_sql field of the newrelic_transaction_tracer_config_t is set"]
#[doc = "  to NEWRELIC_SQL_RAW the query param of the"]
#[doc = "  newrelic_datastore_segment_config_t is reported to New Relic with"]
#[doc = "  alphanumeric characters set to \'?\'"]
pub const _newrelic_tt_recordsql_t_NEWRELIC_SQL_OBFUSCATED: _newrelic_tt_recordsql_t = 2;
#[doc = " @brief Configuration values used to configure how SQL queries"]
#[doc = " are recorded and reported to New Relic."]
#[doc = ""]
#[doc = " @see newrelic_transaction_tracer_config_t"]
pub type _newrelic_tt_recordsql_t = u32;
pub use self::_newrelic_tt_recordsql_t as newrelic_tt_recordsql_t;
#[doc = " Use 4*apdex(T) as the minimum time a transaction must take before it is"]
#[doc = "  eligible for a transaction trace."]
pub const _newrelic_transaction_tracer_threshold_t_NEWRELIC_THRESHOLD_IS_APDEX_FAILING:
    _newrelic_transaction_tracer_threshold_t = 0;
#[doc = " Use the value given in the duration_us field as the minimum time a"]
#[doc = "  transaction must take before it is eligible for a transaction trace."]
pub const _newrelic_transaction_tracer_threshold_t_NEWRELIC_THRESHOLD_IS_OVER_DURATION:
    _newrelic_transaction_tracer_threshold_t = 1;
#[doc = " @brief Configuration values used to configure the behaviour of the"]
#[doc = " transaction tracer."]
#[doc = ""]
#[doc = "  @see newrelic_transaction_tracer_config_t"]
pub type _newrelic_transaction_tracer_threshold_t = u32;
pub use self::_newrelic_transaction_tracer_threshold_t as newrelic_transaction_tracer_threshold_t;
#[doc = " @brief Configuration used to configure transaction tracing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _newrelic_transaction_tracer_config_t {
    #[doc = "  @brief Whether to enable transaction traces."]
    #[doc = ""]
    #[doc = "  Default: true."]
    pub enabled: bool,
    #[doc = "  @brief Whether to consider transactions for trace generation based on the apdex"]
    #[doc = "  configuration or a specific duration."]
    #[doc = ""]
    #[doc = "  Default: NEWRELIC_THRESHOLD_IS_APDEX_FAILING."]
    pub threshold: newrelic_transaction_tracer_threshold_t,
    #[doc = "  @brief If the SDK configuration threshold is set to"]
    #[doc = "  NEWRELIC_THRESHOLD_IS_OVER_DURATION, this field specifies the minimum"]
    #[doc = "  transaction time before a trace may be generated, in microseconds."]
    #[doc = ""]
    #[doc = "  Default: 0."]
    pub duration_us: newrelic_time_us_t,
    #[doc = "  @brief Sets the threshold above which the New Relic SDK will record a"]
    #[doc = "  stack trace for a transaction trace, in microseconds."]
    #[doc = ""]
    #[doc = "  Default: 500000, or 0.5 seconds."]
    pub stack_trace_threshold_us: newrelic_time_us_t,
    pub datastore_reporting: _newrelic_transaction_tracer_config_t__bindgen_ty_1,
}
#[doc = "  @brief The datastore_reporting field of newrelic_transaction_tracer_config_t"]
#[doc = "  is a collection of configuration values that control how certain"]
#[doc = "  characteristics of datastore queries are recorded."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _newrelic_transaction_tracer_config_t__bindgen_ty_1 {
    #[doc = "  @brief Controls whether slow datastore queries are recorded."]
    #[doc = ""]
    #[doc = "  If set to true for a transaction, the transaction tracer records"]
    #[doc = "  the top-10 slowest queries along with a stack trace of where the"]
    #[doc = "  call occurred."]
    #[doc = ""]
    #[doc = "  Default: true."]
    pub enabled: bool,
    #[doc = "  @brief Controls the format of the sql put into transaction traces for"]
    #[doc = "  supported sql-like products."]
    #[doc = ""]
    #[doc = "  Only relevant if the datastore_reporting.enabled field is set to true."]
    #[doc = ""]
    #[doc = "  - If set to NEWRELIC_SQL_OFF, transaction traces have no sql in them."]
    #[doc = "  - If set to NEWRELIC_SQL_RAW, the sql is added to the transaction"]
    #[doc = "    trace as-is."]
    #[doc = "  - If set to NEWRELIC_SQL_OBFUSCATED, alphanumeric characters are set"]
    #[doc = "    to \'?\'. For example \'SELECT * FROM table WHERE foo = 42\' is reported"]
    #[doc = "    as \'SELECT * FROM table WHERE foo = ?\'.  These obfuscated queries are"]
    #[doc = "    added to the transaction trace for supported datastore products."]
    #[doc = ""]
    #[doc = "  @warning New Relic highly discourages the use of the NEWRELIC_SQL_RAW setting"]
    #[doc = "  in production environments."]
    #[doc = ""]
    #[doc = "  Default: NEWRELIC_SQL_OBFUSCATED."]
    pub record_sql: newrelic_tt_recordsql_t,
    #[doc = "  @brief Specify the threshold above which a datastore query is considered"]
    #[doc = "  \"slow\", in microseconds."]
    #[doc = ""]
    #[doc = "  Only relevant if the datastore_reporting.enabled field is set to true."]
    #[doc = ""]
    #[doc = "  Default: 500000, or 0.5 seconds."]
    pub threshold_us: newrelic_time_us_t,
}
#[test]
fn bindgen_test_layout__newrelic_transaction_tracer_config_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_newrelic_transaction_tracer_config_t__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_newrelic_transaction_tracer_config_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_newrelic_transaction_tracer_config_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_newrelic_transaction_tracer_config_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_transaction_tracer_config_t__bindgen_ty_1>())).enabled
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_transaction_tracer_config_t__bindgen_ty_1),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_transaction_tracer_config_t__bindgen_ty_1>()))
                .record_sql as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_transaction_tracer_config_t__bindgen_ty_1),
            "::",
            stringify!(record_sql)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_transaction_tracer_config_t__bindgen_ty_1>()))
                .threshold_us as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_transaction_tracer_config_t__bindgen_ty_1),
            "::",
            stringify!(threshold_us)
        )
    );
}
#[test]
fn bindgen_test_layout__newrelic_transaction_tracer_config_t() {
    assert_eq!(
        ::std::mem::size_of::<_newrelic_transaction_tracer_config_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_newrelic_transaction_tracer_config_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_newrelic_transaction_tracer_config_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_newrelic_transaction_tracer_config_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_transaction_tracer_config_t>())).enabled as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_transaction_tracer_config_t),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_transaction_tracer_config_t>())).threshold as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_transaction_tracer_config_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_transaction_tracer_config_t>())).duration_us
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_transaction_tracer_config_t),
            "::",
            stringify!(duration_us)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_transaction_tracer_config_t>()))
                .stack_trace_threshold_us as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_transaction_tracer_config_t),
            "::",
            stringify!(stack_trace_threshold_us)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_transaction_tracer_config_t>())).datastore_reporting
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_transaction_tracer_config_t),
            "::",
            stringify!(datastore_reporting)
        )
    );
}
pub type newrelic_transaction_tracer_config_t = _newrelic_transaction_tracer_config_t;
#[doc = " @brief Configuration used to configure how datastore segments"]
#[doc = " are recorded in a transaction."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _newrelic_datastore_segment_config_t {
    #[doc = " @brief Configuration which controls whether datastore instance"]
    #[doc = "  names are reported to New Relic."]
    #[doc = ""]
    #[doc = " If set to true for a transaction, instance names are reported to New"]
    #[doc = " Relic. More specifically, the host and port_path_or_id fields in a"]
    #[doc = "  newrelic_datastore_segment_params_t passed to"]
    #[doc = "  newrelic_datastore_start_segment() is reported when the"]
    #[doc = "  corresponding transaction is reported."]
    pub instance_reporting: bool,
    #[doc = " @brief Configuration which controls whether datastore database"]
    #[doc = "  names are reported to New Relic."]
    #[doc = ""]
    #[doc = "  If set to true for a transaction, database names are reported to New"]
    #[doc = "  Relic. More specifically, the database_name field in a"]
    #[doc = "  newrelic_datastore_segment_params_t passed to"]
    #[doc = "  newrelic_datastore_start_segment() is reported when the"]
    #[doc = "  corresponding transaction is reported."]
    pub database_name_reporting: bool,
}
#[test]
fn bindgen_test_layout__newrelic_datastore_segment_config_t() {
    assert_eq!(
        ::std::mem::size_of::<_newrelic_datastore_segment_config_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_newrelic_datastore_segment_config_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_newrelic_datastore_segment_config_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_newrelic_datastore_segment_config_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_config_t>())).instance_reporting
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_config_t),
            "::",
            stringify!(instance_reporting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_config_t>())).database_name_reporting
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_config_t),
            "::",
            stringify!(database_name_reporting)
        )
    );
}
pub type newrelic_datastore_segment_config_t = _newrelic_datastore_segment_config_t;
#[doc = " @brief Optional configuration for the underlying communication mechanism"]
#[doc = " between an instrumented application and the daemon. The default is to use"]
#[doc = " a UNIX-domain socket located at /tmp/.newrelic.sock. If this default works"]
#[doc = " for your system, creating this configuration is not necessary."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _newrelic_process_config_t {
    #[doc = "  @brief Specify the communication mechanism by setting daemon_socket to a"]
    #[doc = "  socket name."]
    #[doc = ""]
    #[doc = "  Domain Sockets: If you want to use UNIX domain sockets as the underlying"]
    #[doc = "  communication mechanism, the name assigned to daemon_socket"]
    #[doc = "  must begin with a \"/\", e.g., \"/domain_socket\"."]
    #[doc = ""]
    #[doc = "  TCP Socket: If you want to use a normal TCP socket, set daemon_socket"]
    #[doc = "  to an integer value in the range 1-65534.  This instructs the daemon"]
    #[doc = "  to listen on a normal TCP socket on the port specified."]
    #[doc = ""]
    #[doc = "  Abstract Socket: If you want to use an abstract socket, the name"]
    #[doc = "  assigned to daemon_socket must begin with a \"@\","]
    #[doc = "  e.g., \"@abstract_socket\"."]
    pub daemon_socket: [::std::os::raw::c_char; 512usize],
}
#[test]
fn bindgen_test_layout__newrelic_process_config_t() {
    assert_eq!(
        ::std::mem::size_of::<_newrelic_process_config_t>(),
        512usize,
        concat!("Size of: ", stringify!(_newrelic_process_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_newrelic_process_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_newrelic_process_config_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_process_config_t>())).daemon_socket as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_process_config_t),
            "::",
            stringify!(daemon_socket)
        )
    );
}
pub type newrelic_process_config_t = _newrelic_process_config_t;
#[doc = " @brief Configuration used to describe application name, license key, as"]
#[doc = " well as optional transaction tracer and datastore configuration."]
#[doc = ""]
#[doc = " @see newrelic_create_app_config()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _newrelic_app_config_t {
    #[doc = " @brief Specifies the name of the application to which data shall be reported."]
    pub app_name: [::std::os::raw::c_char; 255usize],
    #[doc = " @brief Specifies the New Relic license key to use."]
    pub license_key: [::std::os::raw::c_char; 255usize],
    #[doc = "  @brief Optional.  Specifies the New Relic provided host. There is little reason"]
    #[doc = "  to ever change this from the default."]
    pub redirect_collector: [::std::os::raw::c_char; 100usize],
    #[doc = "  @brief Optional. Specifies the file to be used for C SDK logs."]
    #[doc = ""]
    #[doc = "  If no filename is provided, no logging shall occur."]
    pub log_filename: [::std::os::raw::c_char; 512usize],
    #[doc = " @brief Optional. Specifies the logfile\'s level of detail."]
    #[doc = ""]
    #[doc = " There is little reason to change this from the default value except"]
    #[doc = " in troubleshooting scenarios."]
    #[doc = ""]
    #[doc = " Must be one of the following values: NEWRELIC_LOG_ERROR,"]
    #[doc = " NEWRELIC_LOG_WARNING NEWRELIC_LOG_INFO (default), NEWRELIC_LOG_DEBUG."]
    pub log_level: newrelic_loglevel_t,
    #[doc = "  @brief Optional. The transaction tracer configuration."]
    #[doc = ""]
    #[doc = "  By default, the configuration returned by newrelic_new_config()"]
    #[doc = "  will enable transaction traces, with the threshold set to"]
    #[doc = "  NEWRELIC_THRESHOLD_IS_APDEX_FAILING."]
    pub transaction_tracer: newrelic_transaction_tracer_config_t,
    #[doc = "  @brief Optional. The datastore tracer configuration."]
    #[doc = ""]
    #[doc = "  By default, the configuration returned by newrelic_new_config()"]
    #[doc = "  will enable datastore segments with instance_reporting and"]
    #[doc = "  database_name_reporting set to true."]
    pub datastore_tracer: newrelic_datastore_segment_config_t,
}
#[test]
fn bindgen_test_layout__newrelic_app_config_t() {
    assert_eq!(
        ::std::mem::size_of::<_newrelic_app_config_t>(),
        1176usize,
        concat!("Size of: ", stringify!(_newrelic_app_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_newrelic_app_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_newrelic_app_config_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_newrelic_app_config_t>())).app_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_app_config_t),
            "::",
            stringify!(app_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_app_config_t>())).license_key as *const _ as usize
        },
        255usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_app_config_t),
            "::",
            stringify!(license_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_app_config_t>())).redirect_collector as *const _
                as usize
        },
        510usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_app_config_t),
            "::",
            stringify!(redirect_collector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_app_config_t>())).log_filename as *const _ as usize
        },
        610usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_app_config_t),
            "::",
            stringify!(log_filename)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_app_config_t>())).log_level as *const _ as usize
        },
        1124usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_app_config_t),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_app_config_t>())).transaction_tracer as *const _
                as usize
        },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_app_config_t),
            "::",
            stringify!(transaction_tracer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_app_config_t>())).datastore_tracer as *const _ as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_app_config_t),
            "::",
            stringify!(datastore_tracer)
        )
    );
}
pub type newrelic_app_config_t = _newrelic_app_config_t;
#[doc = " @brief Segment configuration used to instrument calls to databases and object"]
#[doc = " stores."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _newrelic_datastore_segment_params_t {
    #[doc = "  @brief Specifies the datastore type, e.g., \"MySQL\", to indicate that the segment"]
    #[doc = "  represents a query against a MySQL database."]
    #[doc = ""]
    #[doc = "  New Relic recommends using the predefined NEWRELIC_DATASTORE_FIREBIRD through"]
    #[doc = "  NEWRELIC_DATASTORE_SYBASE constants for this field. If this field points"]
    #[doc = "  to a string that is not one of NEWRELIC_DATASTORE_FIREBIRD through"]
    #[doc = "  NEWRELIC_DATASTORE_SYBASE, the resulting datastore segment shall be"]
    #[doc = "  instrumented as an unsupported datastore."]
    #[doc = ""]
    #[doc = "  For SQL-like datastores supported by the C SDK, when the"]
    #[doc = "  record_sql field of the newrelic_transaction_tracer_config_t is set"]
    #[doc = "  to NEWRELIC_SQL_RAW or NEWRELIC_SQL_OBFUSCATED, the query param of the"]
    #[doc = "  newrelic_datastore_segment_config_t is reported to New Relic."]
    #[doc = ""]
    #[doc = "  This field is required to be a non-empty, null-terminated string that does"]
    #[doc = "  not include any slash characters.  Empty strings are replaced with the"]
    #[doc = "  string NEWRELIC_DATASTORE_OTHER."]
    pub product: *mut ::std::os::raw::c_char,
    #[doc = "  @brief Optional. Specifies the table or collection being used or queried against."]
    #[doc = ""]
    #[doc = "  If provided, this field is required to be a null-terminated string that"]
    #[doc = "  does not include any slash characters. It is also valid to use the default"]
    #[doc = "  NULL value, in which case the default string of \"other\" will be attached"]
    #[doc = "  to the datastore segment."]
    pub collection: *mut ::std::os::raw::c_char,
    #[doc = "  @brief Optional. Specifies the operation being performed: for example, \"select\""]
    #[doc = "  for an SQL SELECT query, or \"set\" for a Memcached set operation."]
    #[doc = "  While operations may be specified with any case, New Relic suggests"]
    #[doc = "  using lowercase."]
    #[doc = ""]
    #[doc = "  If provided, this field is required to be a null-terminated string that"]
    #[doc = "  does not include any slash characters. It is also valid to use the default"]
    #[doc = "  NULL value, in which case the default string of \"other\" will be attached"]
    #[doc = "  to the datastore segment."]
    pub operation: *mut ::std::os::raw::c_char,
    #[doc = "  @brief Optional. Specifies the datahost host name."]
    #[doc = ""]
    #[doc = "  If provided, this field is required to be a null-terminated string that"]
    #[doc = "  does not include any slash characters. It is also valid to use the default"]
    #[doc = "  NULL value, in which case the default string of \"other\" will be attached"]
    #[doc = "  to the datastore segment."]
    pub host: *mut ::std::os::raw::c_char,
    #[doc = "  @brief Optional. Specifies the port or socket used to connect to the"]
    #[doc = "  datastore."]
    #[doc = ""]
    #[doc = "  If provided, this field is required to be a null-terminated string."]
    pub port_path_or_id: *mut ::std::os::raw::c_char,
    #[doc = "  @brief Optional. Specifies the database name or number in use."]
    #[doc = ""]
    #[doc = "  If provided, this field is required to be a null-terminated string."]
    pub database_name: *mut ::std::os::raw::c_char,
    #[doc = "  @brief Optional. Specifies the database query that was sent to the server."]
    #[doc = ""]
    #[doc = "  For security reasons, this value is only used if you set product to"]
    #[doc = "  a supported sql-like datastore, NEWRELIC_DATASTORE_FIREBIRD,"]
    #[doc = "  NEWRELIC_DATASTORE_INFORMIX, NEWRELIC_DATASTORE_MSSQL, etc. This"]
    #[doc = "  allows the SDK to correctly obfuscate the query. When the product"]
    #[doc = "  is set otherwise, no query information is reported to New Relic."]
    #[doc = ""]
    #[doc = "  If provided, this field is required to be a null-terminated string."]
    pub query: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__newrelic_datastore_segment_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_newrelic_datastore_segment_params_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_newrelic_datastore_segment_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_newrelic_datastore_segment_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_newrelic_datastore_segment_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_params_t>())).product as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_params_t),
            "::",
            stringify!(product)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_params_t>())).collection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_params_t),
            "::",
            stringify!(collection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_params_t>())).operation as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_params_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_params_t>())).host as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_params_t),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_params_t>())).port_path_or_id
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_params_t),
            "::",
            stringify!(port_path_or_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_params_t>())).database_name
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_params_t),
            "::",
            stringify!(database_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_datastore_segment_params_t>())).query as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_datastore_segment_params_t),
            "::",
            stringify!(query)
        )
    );
}
pub type newrelic_datastore_segment_params_t = _newrelic_datastore_segment_params_t;
#[doc = " @brief Segment configuration used to instrument external calls."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _newrelic_external_segment_params_t {
    #[doc = " @brief The URI that was loaded. This field is required to be a null-terminated"]
    #[doc = " string containing a valid URI, and cannot be NULL."]
    pub uri: *mut ::std::os::raw::c_char,
    #[doc = " @brief The procedure used to load the external resource."]
    #[doc = ""]
    #[doc = " In HTTP contexts, this will usually be the request method (eg `GET`,"]
    #[doc = " `POST`, et al). For non-HTTP requests, or protocols that encode more"]
    #[doc = " specific semantics on top of HTTP like SOAP, you may wish to use a"]
    #[doc = " different value that more precisely encodes how the resource was"]
    #[doc = " requested."]
    #[doc = ""]
    #[doc = " If provided, this field is required to be a null-terminated string that"]
    #[doc = " does not include any slash characters. It is also valid to provide NULL,"]
    #[doc = " in which case no procedure will be attached to the external segment."]
    pub procedure: *mut ::std::os::raw::c_char,
    #[doc = " @brief The library used to load the external resource."]
    #[doc = ""]
    #[doc = " If provided, this field is required to be a null-terminated string that"]
    #[doc = " does not include any slash characters. It is also valid to provide NULL,"]
    #[doc = " in which case no library will be attached to the external segment."]
    pub library: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__newrelic_external_segment_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_newrelic_external_segment_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_newrelic_external_segment_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_newrelic_external_segment_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_newrelic_external_segment_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_external_segment_params_t>())).uri as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_external_segment_params_t),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_external_segment_params_t>())).procedure as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_external_segment_params_t),
            "::",
            stringify!(procedure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_newrelic_external_segment_params_t>())).library as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_newrelic_external_segment_params_t),
            "::",
            stringify!(library)
        )
    );
}
pub type newrelic_external_segment_params_t = _newrelic_external_segment_params_t;
extern "C" {
    #[doc = " @brief Configure the C SDK\'s logging system."]
    #[doc = ""]
    #[doc = " If the logging system was previously initialized (either by a prior call to"]
    #[doc = " newrelic_configure_log() or implicitly by a call to newrelic_init() or"]
    #[doc = " newrelic_create_app()), then invoking this function will close the previous"]
    #[doc = " log file."]
    #[doc = ""]
    #[doc = " @param [in] filename The path to the file to write logs to. If this is the"]
    #[doc = " literal string \"stdout\" or \"stderr\", then logs will be written to standard"]
    #[doc = " output or standard error, respectively."]
    #[doc = " @param [in] level The lowest level of log message that will be output."]
    #[doc = " @return true on success; false otherwise."]
    pub fn newrelic_configure_log(
        filename: *const ::std::os::raw::c_char,
        level: newrelic_loglevel_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Initialise the C SDK with non-default settings."]
    #[doc = ""]
    #[doc = " Generally, this function only needs to be called explicitly if the daemon"]
    #[doc = " socket location needs to be customised. By default, \"/tmp/.newrelic.sock\" is"]
    #[doc = " used, which matches the default socket location used by newrelic-daemon if"]
    #[doc = " one isn\'t given."]
    #[doc = ""]
    #[doc = " If an explicit call to this function is required, it must occur before the"]
    #[doc = " first call to newrelic_create_app()."]
    #[doc = ""]
    #[doc = " Subsequent calls to this function after a successful call to newrelic_init()"]
    #[doc = " or newrelic_create_app() will fail."]
    #[doc = ""]
    #[doc = " @param [in] daemon_socket The path to the daemon socket. On Linux, if this"]
    #[doc = " starts with a literal \'@\', then this is treated as the name of an abstract"]
    #[doc = " domain socket instead of a filesystem path. If this is NULL, then the"]
    #[doc = " default behaviour described above will be used."]
    #[doc = " @param [in] time_limit_ms The amount of time, in milliseconds, that the C"]
    #[doc = " SDK will wait for a response from the daemon before considering"]
    #[doc = " initialization to have failed. If this is 0, then a default value will be"]
    #[doc = " used."]
    #[doc = " @return true on success; false otherwise."]
    pub fn newrelic_init(
        daemon_socket: *const ::std::os::raw::c_char,
        time_limit_ms: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Create a populated application configuration."]
    #[doc = ""]
    #[doc = " Given an application name and license key, this method returns an SDK"]
    #[doc = " configuration. Specifically, it returns a pointer to a newrelic_app_config_t"]
    #[doc = " with initialized app_name and license_key fields along with default values"]
    #[doc = " for the remaining fields. The caller should free the configuration"]
    #[doc = " after the application has been created."]
    #[doc = ""]
    #[doc = " @param [in] app_name The name of the application."]
    #[doc = " @param [in] license_key A valid license key supplied by New Relic."]
    #[doc = ""]
    #[doc = " @return An application configuration populated with app_name and"]
    #[doc = " license_key; all other fields are initialized to their defaults."]
    pub fn newrelic_create_app_config(
        app_name: *const ::std::os::raw::c_char,
        license_key: *const ::std::os::raw::c_char,
    ) -> *mut newrelic_app_config_t;
}
extern "C" {
    #[doc = " @brief Destroy the application configuration."]
    #[doc = ""]
    #[doc = " Given an allocated application configuration, newrelic_destroy_app_config()"]
    #[doc = " frees the configuration."]
    #[doc = ""]
    #[doc = " @param [in] config The address of the pointer to the allocated application"]
    #[doc = "             configuration."]
    #[doc = ""]
    #[doc = " @return false if config is NULL or points to NULL; true otherwise."]
    #[doc = ""]
    #[doc = " @warning This function must only be called once for a given application"]
    #[doc = "          configuration."]
    pub fn newrelic_destroy_app_config(config: *mut *mut newrelic_app_config_t) -> bool;
}
extern "C" {
    #[doc = " @brief Create an application."]
    #[doc = ""]
    #[doc = " Given a configuration, newrelic_create_app() returns a pointer to the"]
    #[doc = " newly allocated application, or NULL if there was an error. If successful,"]
    #[doc = " the caller should destroy the application with the supplied"]
    #[doc = " newrelic_destroy_app() when finished."]
    #[doc = ""]
    #[doc = " @param [in] config An application configuration created by"]
    #[doc = " newrelic_create_app_config()."]
    #[doc = " @param [in] timeout_ms Specifies the maximum time to wait for a connection to"]
    #[doc = " be established; a value of 0 causes the method to make only one attempt at"]
    #[doc = " connecting to the daemon."]
    #[doc = ""]
    #[doc = " @return A pointer to an allocated application, or NULL on error; any errors"]
    #[doc = " resulting from a badly-formed configuration are logged."]
    pub fn newrelic_create_app(
        config: *const newrelic_app_config_t,
        timeout_ms: ::std::os::raw::c_ushort,
    ) -> *mut newrelic_app_t;
}
extern "C" {
    #[doc = " @brief Destroy the application."]
    #[doc = ""]
    #[doc = " Given an allocated application, newrelic_destroy_app() closes the logfile"]
    #[doc = " handle and frees any memory used by app to describe the application."]
    #[doc = ""]
    #[doc = " @param [in] app The address of the pointer to the allocated application."]
    #[doc = ""]
    #[doc = " @return false if app is NULL or points to NULL; true otherwise."]
    #[doc = ""]
    #[doc = " @warning This function must only be called once for a given application."]
    pub fn newrelic_destroy_app(app: *mut *mut newrelic_app_t) -> bool;
}
extern "C" {
    #[doc = " @brief Start a web based transaction."]
    #[doc = ""]
    #[doc = " Given an application pointer and transaction name, this function begins"]
    #[doc = " timing a new transaction. It returns a valid pointer to an active New Relic"]
    #[doc = " transaction, newrelic_txn_t.  The return value of this function may be"]
    #[doc = " used as an input parameter to functions that modify an active transaction."]
    #[doc = ""]
    #[doc = " @param [in] app A pointer to an allocation application."]
    #[doc = " @param [in] name The name for the transaction."]
    #[doc = ""]
    #[doc = " @return A pointer to the transaction."]
    pub fn newrelic_start_web_transaction(
        app: *mut newrelic_app_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut newrelic_txn_t;
}
extern "C" {
    #[doc = " @brief Start a non-web based transaction."]
    #[doc = ""]
    #[doc = " Given a valid application and transaction name, this function begins timing"]
    #[doc = " a new transaction and returns a valid pointer to a New Relic transaction,"]
    #[doc = " newrelic_txn_t. The return value of this function may be used as an input"]
    #[doc = " parameter to functions that modify an active transaction."]
    #[doc = ""]
    #[doc = " @param [in] app A pointer to an allocation application."]
    #[doc = " @param [in] name The name for the transaction."]
    #[doc = ""]
    #[doc = " @return A pointer to the transaction."]
    pub fn newrelic_start_non_web_transaction(
        app: *mut newrelic_app_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut newrelic_txn_t;
}
extern "C" {
    #[doc = " @brief Override the timing for the given transaction."]
    #[doc = ""]
    #[doc = " Transactions are normally timed automatically based on when they were started"]
    #[doc = " and ended. Calling this function disables the automatic timing, and uses the"]
    #[doc = " times given instead."]
    #[doc = ""]
    #[doc = " Note that this may cause unusual looking transaction traces. This function"]
    #[doc = " manually alters a transaction\'s start time and duration, but it does not"]
    #[doc = " alter any timing for the segments belonging to the transaction.  As a result,"]
    #[doc = " the sum of all segment durations may be substantively greater or less than"]
    #[doc = " the total duration of the transaction."]
    #[doc = ""]
    #[doc = " It is likely that users of this function will also want to use"]
    #[doc = " newrelic_set_segment_timing() to manually time their segments."]
    #[doc = ""]
    #[doc = " @param [in] transaction    The transaction to manually time."]
    #[doc = " @param [in] start_time     The start time for the segment, in microseconds"]
    #[doc = "                            since the UNIX Epoch."]
    #[doc = " @param [in] duration       The duration of the transaction in microseconds."]
    #[doc = ""]
    #[doc = " @return True if the segment timing was changed; false otherwise."]
    pub fn newrelic_set_transaction_timing(
        transaction: *mut newrelic_txn_t,
        start_time: newrelic_time_us_t,
        duration: newrelic_time_us_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief End a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function stops the transaction\'s"]
    #[doc = " timing, sends any data to the New Relic daemon, and destroys the transaction."]
    #[doc = ""]
    #[doc = " @param [in] transaction_ptr The address of a pointer to an active transaction."]
    #[doc = ""]
    #[doc = " @return false if transaction is NULL or points to NULL; false if data cannot"]
    #[doc = " be sent to newrelic; true otherwise."]
    #[doc = ""]
    #[doc = " @warning This function must only be called once for a given transaction."]
    pub fn newrelic_end_transaction(transaction_ptr: *mut *mut newrelic_txn_t) -> bool;
}
extern "C" {
    #[doc = " @brief Add a custom integer attribute to a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function appends an"]
    #[doc = " integer attribute to the transaction."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] key The name of the attribute."]
    #[doc = " @param [in] value The integer value of the attribute."]
    #[doc = ""]
    #[doc = " @return true if successful; false otherwise."]
    pub fn newrelic_add_attribute_int(
        transaction: *mut newrelic_txn_t,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Add a custom long attribute to a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function appends a"]
    #[doc = " long attribute to the transaction."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] key The name of the attribute."]
    #[doc = " @param [in] value The long value of the attribute."]
    #[doc = ""]
    #[doc = " @return true if successful; false otherwise."]
    pub fn newrelic_add_attribute_long(
        transaction: *mut newrelic_txn_t,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Add a custom double attribute to a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function appends a"]
    #[doc = " double attribute to the transaction."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] key The name of the attribute."]
    #[doc = " @param [in] value The double value of the attribute."]
    #[doc = ""]
    #[doc = " @return true if successful; false otherwise."]
    pub fn newrelic_add_attribute_double(
        transaction: *mut newrelic_txn_t,
        key: *const ::std::os::raw::c_char,
        value: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Add a custom string attribute to a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function appends a"]
    #[doc = " string attribute to the transaction."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] key The name of the attribute."]
    #[doc = " @param [in] value The string value of the attribute."]
    #[doc = ""]
    #[doc = " @return true if successful; false otherwise."]
    pub fn newrelic_add_attribute_string(
        transaction: *mut newrelic_txn_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Record an error in a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function records an error"]
    #[doc = " inside of the transaction."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] priority The error\'s priority."]
    #[doc = " @param [in] errmsg A string comprising the error message."]
    #[doc = " @param [in] errclass A string comprising the error class."]
    pub fn newrelic_notice_error(
        transaction: *mut newrelic_txn_t,
        priority: ::std::os::raw::c_int,
        errmsg: *const ::std::os::raw::c_char,
        errclass: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _newrelic_segment_t {
    _unused: [u8; 0],
}
#[doc = " @brief A segment within a transaction.  Within an active transaction,"]
#[doc = " instrument additional segments for greater granularity.  Instrument"]
#[doc = " external calls with newrelic_start_external_segment().  Instrument"]
#[doc = " datastore calls with newrelic_start_datastore_segment().  Instrument"]
#[doc = " arbitrary function calls or other code with newrelic_start_segment()."]
#[doc = " All segments must be ended with newrelic_end_segment().  Examples of"]
#[doc = " instrumenting segments are available in the examples directory."]
pub type newrelic_segment_t = _newrelic_segment_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _newrelic_custom_event_t {
    _unused: [u8; 0],
}
#[doc = " @brief A Custom Event. The C SDK provides a Custom Events API"]
#[doc = " that allows one to send custom events to New Relic Insights."]
#[doc = " To send an event, start a transaction and use the"]
#[doc = " newrelic_create_custom_event() and newrelic_record_custom_event()"]
#[doc = " functions. Examples of sending custom events are available in the"]
#[doc = " examples directory."]
pub type newrelic_custom_event_t = _newrelic_custom_event_t;
extern "C" {
    #[doc = " @brief Record the start of a custom segment in a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction this function creates a custom segment to be"]
    #[doc = " recorded as part of the transaction. A subsequent call to"]
    #[doc = " newrelic_end_segment() records the end of the segment."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] name The segment name. If NULL or an invalid name is passed,"]
    #[doc = " this defaults to \"Unnamed segment\"."]
    #[doc = " @param [in] category The segment category. If NULL or an invalid category is"]
    #[doc = " passed, this defaults to \"Custom\"."]
    #[doc = ""]
    #[doc = " @return A pointer to a valid custom segment; NULL otherwise."]
    #[doc = ""]
    pub fn newrelic_start_segment(
        transaction: *mut newrelic_txn_t,
        name: *const ::std::os::raw::c_char,
        category: *const ::std::os::raw::c_char,
    ) -> *mut newrelic_segment_t;
}
extern "C" {
    #[doc = " @brief Record the start of a datastore segment in a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction and valid parameters, this function creates a"]
    #[doc = " datastore segment to be recorded as part of the transaction. A subsequent"]
    #[doc = " call to newrelic_end_segment() records the end of the segment."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] params Valid parameters describing a datastore segment."]
    #[doc = ""]
    #[doc = " @return A pointer to a valid datastore segment; NULL otherwise."]
    #[doc = ""]
    pub fn newrelic_start_datastore_segment(
        transaction: *mut newrelic_txn_t,
        params: *const newrelic_datastore_segment_params_t,
    ) -> *mut newrelic_segment_t;
}
extern "C" {
    #[doc = " @brief Start recording an external segment within a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function creates an external segment"]
    #[doc = " inside of the transaction and marks it as having been started. An external"]
    #[doc = " segment is generally used to represent a HTTP or RPC request."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] params      The parameters describing the external request. All"]
    #[doc = "                         parameters are copied, and no references to the"]
    #[doc = "                         pointers provided are kept after this function"]
    #[doc = "                         returns."]
    #[doc = " @return A pointer to an external segment, which may then be provided to"]
    #[doc = "         newrelic_end_segment() when the external request is complete. If an"]
    #[doc = "         error occurs when creating the external segment, NULL is returned,"]
    #[doc = "         and a log message will be written to the SDK log at LOG_ERROR"]
    #[doc = "         level."]
    pub fn newrelic_start_external_segment(
        transaction: *mut newrelic_txn_t,
        params: *const newrelic_external_segment_params_t,
    ) -> *mut newrelic_segment_t;
}
extern "C" {
    #[doc = " @brief Set the parent for the given segment."]
    #[doc = ""]
    #[doc = " This function changes the parent for the given segment to another segment."]
    #[doc = " Both segments must exist on the same transaction, and must not have ended."]
    #[doc = ""]
    #[doc = " @param [in] segment The segment to reparent."]
    #[doc = " @param [in] parent  The new parent segment."]
    #[doc = " @return True if the segment was successfully reparented; false otherwise."]
    #[doc = ""]
    #[doc = " @warning Do not attempt to use a segment that has had newrelic_end_segment()"]
    #[doc = "          called on it as a segment or parent: this will result in a"]
    #[doc = "          use-after-free scenario, and likely a crash."]
    pub fn newrelic_set_segment_parent(
        segment: *mut newrelic_segment_t,
        parent: *mut newrelic_segment_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the transaction\'s root as the parent for the given segment."]
    #[doc = ""]
    #[doc = " Transactions are represented by a collection of segments. Segments are"]
    #[doc = " created by calls to newrelic_start_segment(),"]
    #[doc = " newrelic_start_datastore_segment() and newrelic_start_external_segment()."]
    #[doc = " In addition, a transaction has an automatically-created root segment that"]
    #[doc = " represents the entrypoint of the transaction. In some cases, users may want"]
    #[doc = " to manually parent their segments with the transaction\'s root segment."]
    #[doc = ""]
    #[doc = " @param [in] segment  The segment to be parented."]
    #[doc = ""]
    #[doc = " @return True if the segment was successfully reparented; false otherwise."]
    #[doc = ""]
    #[doc = " @warning Do not attempt to use a segment that has had newrelic_end_segment()"]
    #[doc = "          called on it as a segment or parent: this will result in a"]
    #[doc = "          use-after-free scenario, and likely a crash."]
    pub fn newrelic_set_segment_parent_root(segment: *mut newrelic_segment_t) -> bool;
}
extern "C" {
    #[doc = " @brief Override the timing for the given segment."]
    #[doc = ""]
    #[doc = " Segments are normally timed automatically based on when they were started"]
    #[doc = " and ended. Calling this function disables the automatic timing, and uses the"]
    #[doc = " times given instead."]
    #[doc = ""]
    #[doc = " Note that this may cause unusual looking transaction traces, as this"]
    #[doc = " function does not change the parent segment. It is likely that users of this"]
    #[doc = " function will also want to use newrelic_set_segment_parent() to manually"]
    #[doc = " parent their segments."]
    #[doc = ""]
    #[doc = " @param [in] segment    The segment to manually time."]
    #[doc = " @param [in] start_time The start time for the segment, in microseconds since"]
    #[doc = "                        the start of the transaction."]
    #[doc = " @param [in] duration   The duration of the segment in microseconds."]
    #[doc = " @return True if the segment timing was changed; false otherwise."]
    pub fn newrelic_set_segment_timing(
        segment: *mut newrelic_segment_t,
        start_time: newrelic_time_us_t,
        duration: newrelic_time_us_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Record the completion of a segment in a transaction."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function records the segment\'s metrics"]
    #[doc = " on the transaction."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in,out] segment_ptr The address of a valid segment."]
    #[doc = " Before the function returns, any segment_ptr memory is freed;"]
    #[doc = " segment_ptr is set to NULL to avoid any potential double free errors."]
    #[doc = ""]
    #[doc = " @return true if the parameters represented an active transaction"]
    #[doc = " and custom segment to record as complete; false otherwise."]
    #[doc = " If an error occurred, a log message will be written to the"]
    #[doc = " SDK log at LOG_ERROR level."]
    pub fn newrelic_end_segment(
        transaction: *mut newrelic_txn_t,
        segment_ptr: *mut *mut newrelic_segment_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Creates a custom event"]
    #[doc = ""]
    #[doc = " Attributes can be added to the custom event using the"]
    #[doc = " newrelic_custom_event_add_* family of functions. When the required attributes"]
    #[doc = " have been added, the custom event can be recorded using"]
    #[doc = " newrelic_record_custom_event()."]
    #[doc = ""]
    #[doc = " When passed to newrelic_record_custom_event, the custom event will be freed."]
    #[doc = " If you can\'t pass an allocated event to newrelic_record_custom_event, use the"]
    #[doc = " newrelic_discard_custom_event function to free the event."]
    #[doc = ""]
    #[doc = " @param [in] event_type The type/name of the event"]
    #[doc = ""]
    #[doc = " @return A pointer to a custom event; NULL otherwise."]
    pub fn newrelic_create_custom_event(
        event_type: *const ::std::os::raw::c_char,
    ) -> *mut newrelic_custom_event_t;
}
extern "C" {
    #[doc = " @brief Frees the memory for custom events created via the"]
    #[doc = " newrelic_create_custom_event function"]
    #[doc = ""]
    #[doc = " This function is here in case there\'s an allocated newrelic_custom_event_t"]
    #[doc = " that ends up not being recorded as a custom event, but still needs to be"]
    #[doc = " freed"]
    #[doc = ""]
    #[doc = " @param [in] event The address of a valid custom event, @see"]
    #[doc = "             newrelic_create_custom_event()."]
    pub fn newrelic_discard_custom_event(event: *mut *mut newrelic_custom_event_t);
}
extern "C" {
    #[doc = " @brief Records the custom event."]
    #[doc = ""]
    #[doc = " Given an active transaction, this function adds the custom event to the"]
    #[doc = " transaction and timestamps it, ensuring the event will be sent to New Relic."]
    #[doc = ""]
    #[doc = " @param [in] transaction pointer to a started transaction"]
    #[doc = " @param [in] event The address of a valid custom event, @see"]
    #[doc = "                   newrelic_create_custom_event()."]
    #[doc = ""]
    #[doc = " newrelic_create_custom_event"]
    pub fn newrelic_record_custom_event(
        transaction: *mut newrelic_txn_t,
        event: *mut *mut newrelic_custom_event_t,
    );
}
extern "C" {
    #[doc = " @brief Adds an int key/value pair to the custom event\'s attributes"]
    #[doc = ""]
    #[doc = " Given a custom event, this function adds an integer attributes to the event."]
    #[doc = ""]
    #[doc = " @param [in] event A valid custom event, @see newrelic_create_custom_event()."]
    #[doc = " @param [in] key the string key for the key/value pair"]
    #[doc = " @param [in] value the integer value of the key/value pair"]
    #[doc = ""]
    #[doc = " @return false indicates the attribute could not be added"]
    pub fn newrelic_custom_event_add_attribute_int(
        event: *mut newrelic_custom_event_t,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Adds a long key/value pair to the custom event\'s attributes"]
    #[doc = ""]
    #[doc = " Given a custom event, this function adds a long attribute to the event."]
    #[doc = ""]
    #[doc = " @param [in] event A valid custom event, @see newrelic_create_custom_event()."]
    #[doc = " @param [in] key the string key for the key/value pair"]
    #[doc = " @param [in] value the long value of the key/value pair"]
    #[doc = ""]
    #[doc = " @return false indicates the attribute could not be added"]
    pub fn newrelic_custom_event_add_attribute_long(
        event: *mut newrelic_custom_event_t,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Adds a double key/value pair to the custom event\'s attributes"]
    #[doc = ""]
    #[doc = " Given a custom event, this function adds a double attribute to the event."]
    #[doc = ""]
    #[doc = " @param [in] event A valid custom event, @see newrelic_create_custom_event()."]
    #[doc = " @param [in] key the string key for the key/value pair"]
    #[doc = " @param [in] value the double value of the key/value pair"]
    #[doc = ""]
    #[doc = " @return false indicates the attribute could not be added"]
    pub fn newrelic_custom_event_add_attribute_double(
        event: *mut newrelic_custom_event_t,
        key: *const ::std::os::raw::c_char,
        value: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Adds a string key/value pair to the custom event\'s attributes"]
    #[doc = ""]
    #[doc = " Given a custom event, this function adds a char* (string) attribute to the"]
    #[doc = " event."]
    #[doc = ""]
    #[doc = " @param [in] event A valid custom event, @see newrelic_create_custom_event()."]
    #[doc = " @param [in] key the string key for the key/value pair"]
    #[doc = " @param [in] value the string value of the key/value pair"]
    #[doc = ""]
    #[doc = " @return false indicates the attribute could not be added"]
    pub fn newrelic_custom_event_add_attribute_string(
        event: *mut newrelic_custom_event_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the SDK version."]
    #[doc = ""]
    #[doc = " @return A NULL-terminated string containing the C SDK version number. If"]
    #[doc = " the version number is unavailable, the string \"NEWRELIC_VERSION\" will be"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " This string is owned by the SDK, and must not be freed or modified."]
    pub fn newrelic_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Generate a custom metric."]
    #[doc = ""]
    #[doc = " Given an active transaction and valid parameters, this function creates a"]
    #[doc = " custom metric to be recorded as part of the transaction."]
    #[doc = ""]
    #[doc = " @param [in] transaction An active transaction."]
    #[doc = " @param [in] metric_name The name/identifier for the metric."]
    #[doc = " @param [in] milliseconds The amount of time the metric will"]
    #[doc = "             record, in milliseconds."]
    #[doc = ""]
    #[doc = " @return true on success."]
    pub fn newrelic_record_custom_metric(
        transaction: *mut newrelic_txn_t,
        metric_name: *const ::std::os::raw::c_char,
        milliseconds: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Ignore the current transaction"]
    #[doc = ""]
    #[doc = " Given a transaction, this function instructs the C SDK to not send data to"]
    #[doc = " New Relic for that transaction."]
    #[doc = ""]
    #[doc = " @warning Even when newrelic_ignore_transaction() is called, one must still"]
    #[doc = " call newrelic_end_transaction() to free the memory used by the transaction"]
    #[doc = " and avoid a memory leak."]
    #[doc = ""]
    #[doc = " @param [in] transaction A transaction."]
    #[doc = ""]
    #[doc = " @return true on success."]
    pub fn newrelic_ignore_transaction(transaction: *mut newrelic_txn_t) -> bool;
}
